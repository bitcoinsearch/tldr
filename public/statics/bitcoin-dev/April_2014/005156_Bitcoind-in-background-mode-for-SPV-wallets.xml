<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>1</id>
  <title>Bitcoind-in-background mode for SPV wallets</title>
  <updated>2023-06-08T19:18:12.752089+00:00</updated>
  <author>
    <name>Peter Todd 2014-04-09 16:03:08</name>
  </author>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>1</id>
    <title>Bitcoind-in-background mode for SPV wallets</title>
    <updated>2023-06-08T19:18:12.752089+00:00</updated>
    <link href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2014-April/005156.html" rel="alternate"/>
    <summary>Developers of SPV wallets are being encouraged to consider adding a 'full node' option to their wallets. The decrease in the number of full nodes could be due to less people running Bitcoin Core, as other wallets are getting ahead in both features and usability. While innovation in wallets is great, it is worrying that the number of full nodes decreases. This option would spin a bitcoind process in the background, which would sync in the background while the wallet shows statistics about the node but is not dependent on it. In exchange, the user would get increased security as the SPV wallet would have a local trusted node. The two main reasons for using a full node are privacy and security. Bloom filters give away accurate statistical information about what coins you own to whoever you happen to be connected to. An attacker can easily use this to deanonymize you even if you don't reuse addresses; Tor does not help much against this attack. Also, SPV means users must trust miners to do validation for them. With the extremely high degree of mining centralization currently existing, it would only take one or two pools getting hacked for an attacker to be able to get enough hashing power to easily fool your SPV wallet into accepting a fake transaction.Partial UTXO set mode would be a great long-term goal for developers, as it would offer them something they can provide to their users. Specific interfaces, special builds, bindings, dlls, etc., could also be added to accommodate embedded usage.</summary>
    <published>2014-04-09T16:03:08+00:00</published>
  </entry>
</feed>

<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>1</id>
  <title>ASIC-proof mining</title>
  <updated>2023-06-09T00:40:59.591217+00:00</updated>
  <author>
    <name>Eugen Leitl 2014-07-04 11:08:34</name>
  </author>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>1</id>
    <title>ASIC-proof mining</title>
    <updated>2023-06-09T00:40:59.591217+00:00</updated>
    <link href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2014-July/006188.html" rel="alternate"/>
    <summary>In a discussion about possible ways to make mining Bitcoin "unASICable," Alan Reiner suggests using the hash of a prevBlockHash||nonce as the starting point for 1,000,000 lookup operations. The output of each previous lookup would be used to determine which block and transaction is used for the next lookup. This method means that you would need the entire blockchain available, even though only a small fraction of it is used for each "hash." This could achieve the goal of making mining unASICable without requiring the full 20 GB of reading on every hash. Another participant in the discussion suggests that anything involving lots of unpredictable memory accesses to a large chunk of fast memory is unASICable. They propose that the data vector could be derived by the same means as an one-time pad and loaded and locked into memory after boot. If the vector is large enough, it won't profit from embedded RAM bandwidth/speedup. The only way to speed up would be clustering, which doesn't offer economies of scale.</summary>
    <published>2014-07-04T11:08:34+00:00</published>
  </entry>
</feed>

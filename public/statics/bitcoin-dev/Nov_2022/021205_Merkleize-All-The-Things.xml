<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>1</id>
  <title>Merkleize All The Things</title>
  <updated>2023-06-16T03:05:57.871031+00:00</updated>
  <author>
    <name>Salvatore Ingala 2022-11-12 15:04:20</name>
  </author>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>1</id>
    <title>Merkleize All The Things</title>
    <updated>2023-06-16T03:05:57.871031+00:00</updated>
    <link href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2022-November/021205.html" rel="alternate"/>
    <summary>The bisection protocol is used in a larger protocol that ensures scalability by not ending up on the chain and only resulting in a longer chain of transactions in case of a challenge. In a simpler example, Alice and Bob make a bet where Alice claims to know how to multiply by 256 and Bob disagrees. They commit one coin each, with Bob choosing a number x and Alice computing y = 256*x. If Bob's independently computed result is not equal to y, a challenge begins. The bisection protocol is used to settle the disagreement, with Alice and Bob building Merkle trees that commit to the state of computation before the leftmost leaf in the subtree, the state after the rightmost leaf, and the hash of sub-trace for the sub-tree. The challenge continues until the root of the computation trace is reached. The operation in the final step is simple enough that Script can verify its correctness. While the protocol has some missing aspects, such as the need for bonds to incentivize cooperation and additional transitions at every step, the code and scripts of the bisection protocol are independent of the actual execution and can be precomputed before the initial covenant is created.</summary>
    <published>2022-11-12T15:04:20+00:00</published>
  </entry>
</feed>

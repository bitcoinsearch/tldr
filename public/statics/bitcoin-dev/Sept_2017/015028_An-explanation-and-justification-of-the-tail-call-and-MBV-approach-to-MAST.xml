<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>1</id>
  <title>An explanation and justification of the tail-call and MBV approach to MAST</title>
  <updated>2023-06-12T18:59:18.139949+00:00</updated>
  <author>
    <name>Mark Friedenbach 2017-09-20 22:51:39</name>
  </author>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>1</id>
    <title>An explanation and justification of the tail-call and MBV approach to MAST</title>
    <updated>2023-06-12T18:59:18.139949+00:00</updated>
    <link href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2017-September/015028.html" rel="alternate"/>
    <summary>In recent weeks, developers have been educated on the MERKLEBRANCHVERIFY opcode and tail-call execution semantics. However, it has been noted that the concept presented in the Bitcoin Improvement Proposals (BIPs) may not be as clear as it could be. The article begins by discussing P2SH and its limitations before introducing macro-op fusion as a way to generalize P2SH. The article then delves into implicit tail-call execution semantics and P2SH, followed by MAST with tail-call alone or an aside on general recursion. The article concludes with an explanation of Merkle branch verify as a solution for proving an item was drawn from the set used to construct a given Merkle tree, with primary motivating applications of Merkle branch verify (MBV) being MBV and MAST and MBV and Key Aggregation.The author advocates for permission-less innovation in Bitcoin consensus features, supporting the UNIX philosophy of writing simple, modular tools that can work together. The proposals for tail-call and Merklized Abstract Syntax Trees (MAST) enable complex features with minimal changes to the consensus code, minimizing review burden and technical debt. The primitives proposed can be combined with other features to support various use cases beyond vanilla MAST. These include honeypot bounties, split proofs, Wuille-Maxwell tree signatures, delegation, signature-time commitment, and reusable Lamport keys. The author argues that small, modular, incremental, and reusable changes create a platform for unrestricted innovation, unlike rigid templates that require workarounds for each future innovation. While a template-matching implementation has efficiency gains over user-specified schemes, the author believes it is best to deploy MBV, tail-call, and overhaul the CHECKSIG operator before adopting an ideal MAST-supporting witness type to ensure simplicity and succinctness while supporting necessary use cases identified by actual feature usage.</summary>
    <published>2017-09-20T22:51:39+00:00</published>
  </entry>
</feed>

<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>1</id>
  <title>Building Blocks of the State Machine Approach to Consensus</title>
  <updated>2023-06-11T05:49:39.664935+00:00</updated>
  <author>
    <name>Peter Todd 2016-06-23 11:21:16</name>
  </author>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>1</id>
    <title>Building Blocks of the State Machine Approach to Consensus</title>
    <updated>2023-06-11T05:49:39.664935+00:00</updated>
    <link href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-June/012806.html" rel="alternate"/>
    <summary>In a bitcoin-dev mailing list discussion, it was suggested that Bitcoin could embed a Lisp interpreter such as Scheme, reverse engineer the current protocol into Lisp inside C++, run this alternative engine alongside the current one as an option for fine-tuning and eventually fade out the Lisp-written validation code instead of the current one. The idea of using Scheme in particular was considered due to its small and minimal size, and ease of embedding in C++. However, it was pointed out that finding a suitable Scheme interpreter may be difficult and starting from scratch might be easier. It was also suggested that having validation code written in a functional scripting language like Lisp could be a better option than using the libconsensus library. The discussion also touched on the idea of using seals to prevent transaction hash collisions. The abstract notion of a single-use seal was explained and it was noted that it does not require transactions to have indexes and therefore would not require global consensus to implement. Additionally, the use of C++ in Bitcoin was discussed, with one participant suggesting that it is a strong language for what it does, although it is difficult to master and there are no other options due to consensus.</summary>
    <published>2016-06-23T11:21:16+00:00</published>
  </entry>
</feed>

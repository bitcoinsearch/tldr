<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>1</id>
  <title>LN &amp; Coinjoin, a Great Tx Format Wedding</title>
  <updated>2023-06-13T23:36:01.218956+00:00</updated>
  <author>
    <name>ZmnSCPxj 2020-02-23 00:59:46</name>
  </author>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>1</id>
    <title>LN &amp; Coinjoin, a Great Tx Format Wedding</title>
    <updated>2023-06-13T23:36:01.218956+00:00</updated>
    <link href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-February/017635.html" rel="alternate"/>
    <summary>In a recent conversation on the bitcoin-dev mailing list, Antoine Riard asked how a Bitcoin transaction could leak protocol usage. He listed several ways, including the output type, spending policy, outputs ordering, nLocktime/nSequence, RBF-signaling, equal-value outputs, weird watermark, fees strategy like CPFP, and in-protocol announcements. ZmnSCPxj added that utxo selection algorithm and nVersion are also possible ways for leakage. Regarding CoinJoin in this context, ZmnSCPxj suggested that CoinJoinXT could address this exact point in a taproot/schnorr world. CoinJoinXT is a client-server model with multiple clients mixing, which can make it difficult to detect if none of the participants reveal it. However, if any participants reveal it, there is a fallback such that it is almost as good as an equal-value CoinJoin but takes up more block space. It is not immediately obvious that it is a CoinJoinXT from just a simple transaction analysis, which is hoped to deter simple policies like "check N transactions back for a transaction with more than one equal-valued output".</summary>
    <published>2020-02-23T00:59:46+00:00</published>
  </entry>
</feed>

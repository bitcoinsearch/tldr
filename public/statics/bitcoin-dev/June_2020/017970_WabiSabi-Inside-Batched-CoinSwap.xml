<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>1</id>
  <title>WabiSabi Inside Batched CoinSwap</title>
  <updated>2023-06-14T02:28:55.038424+00:00</updated>
  <author>
    <name>ZmnSCPxj 2020-06-12 05:43:29</name>
  </author>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>1</id>
    <title>WabiSabi Inside Batched CoinSwap</title>
    <updated>2023-06-14T02:28:55.038424+00:00</updated>
    <link href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-June/017970.html" rel="alternate"/>
    <summary>The WabiSabi protocol is a novel crypto that has not been proven to be secure and private. While WabiSabi is planned for some kind of CoinJoin operation, it creates a transaction where the inputs are linked to the outputs, which is not ideal. A better solution would be to use CoinSwap, and the new swap scheme Succinct Atomic Swaps, which can be used to solve this problem. By using Batched CoinSwap, makers can act as WabiSabi servers, and batched takers can act as WabiSabi clients. However, naive CoinSwap requires that outputs from the maker be linkable, at least by the maker, to inputs given to the maker, which is precisely the information that WabiSabi seeks to hide from the server. Signature Selling can be used as a basis for atomic CoinSwap, and which we will use in this proposal. WabiSabi replaces blind signatures with credentials. The primary advantage of credentials is that credentials can include a homomorphic value. We use this homomorphic value to represent a blinded amount. The WabiSabi process involves a single server that issues credentials and multiple clients that the server serves. Clients can exchange value by swapping credentials, then claiming credentials they received from the server and exchanging them for fresh credentials. In the Batched CoinSwap, Macky operates as a WabiSabi server, and Alice, Bob, and Carol operate as WabiSabi clients. Rather than generate a single CoinJoin transaction, they generate a CoinSwap operation. First, they all agree on future blockheights L1 and L2, where L1 is when the maker's funds are timelocked, and L2 is when the takers' funds are timelocked. Then, they proceed to create the CoinSwap transaction, which involves several steps. This proposal uses the Signature Selling technique to arrange for a CoinSwap to occur without the make being able to link outputs to inputs.</summary>
    <published>2020-06-12T05:43:29+00:00</published>
  </entry>
</feed>

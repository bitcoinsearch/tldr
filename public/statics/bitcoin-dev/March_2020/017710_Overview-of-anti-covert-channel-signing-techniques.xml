<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>1</id>
  <title>Overview of anti-covert-channel signing techniques</title>
  <updated>2023-06-13T23:53:59.119063+00:00</updated>
  <author>
    <name>Dustin Dettmer 2020-03-24 14:51:32</name>
  </author>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>1</id>
    <title>Overview of anti-covert-channel signing techniques</title>
    <updated>2023-06-13T23:53:59.119063+00:00</updated>
    <link href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-March/017710.html" rel="alternate"/>
    <summary>In this context, Dustin is explaining to Tim about a technique to protect against the stealing of funds by malicious hardware or software. He mentions that there are some side benefits as well. The storage solution could be any way in which bitcoins are stored, and the technique works regardless. If the SW party is split into two, generator and validator, some useful security properties emerge. The generator creates and passes on receiving addresses and withdrawal transactions while remaining offline, whereas the validator double checks everything the generator did. It works best if the validator is written entirely independently of the generator. The external software runs on a second SW, which is the second stage, and it would work with a non-trivial/random unhardened derivation just fine. K commitment is one of the proposed solutions collected by Peter in the thread. By committing to some k value, the hardware wallet cannot sneak out private keys in the R value.</summary>
    <published>2020-03-24T14:51:32+00:00</published>
  </entry>
</feed>

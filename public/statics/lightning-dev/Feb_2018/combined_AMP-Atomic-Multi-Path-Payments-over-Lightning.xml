<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <id>2</id>
  <title>Combined summary - AMP: Atomic Multi-Path Payments over Lightning</title>
  <updated>2023-05-20T08:01:05.344558+00:00</updated>
  <author>
    <name>Olaoluwa Osuntokun 2018-02-06 05:26:30</name>
  </author>
  <author>
    <name>Olaoluwa Osuntokun 2018-02-07 00:03:45</name>
  </author>
  <link href="lightning-dev/Feb_2018/000993_AMP-Atomic-Multi-Path-Payments-over-Lightning.xml" rel="alternate"/>
  <link href="lightning-dev/Feb_2018/000999_AMP-Atomic-Multi-Path-Payments-over-Lightning.xml" rel="alternate"/>
  <generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator>
  <entry>
    <id>2</id>
    <title>Combined summary - AMP: Atomic Multi-Path Payments over Lightning</title>
    <updated>2023-05-20T08:01:05.345556+00:00</updated>
    <link href="https://lists.linuxfoundation.org/pipermail/lightning-dev/2018-February/000993.html" rel="alternate"/>
    <summary>A new feature called Atomic Multi-path Payments (AMP) has been introduced to Lightning Network. The AMPs protocol is designed to achieve atomicity and avoid payment hash reuse while allowing logical payments larger than the current maximum value of an individual payment. It uses some unused space in the onion per-hop payload of the onion blob to signal the protocol and deliver specific data. Additive secret sharing is used to ensure that the receiver cannot pull the payment until they have enough shares to reconstruct the original pre-image.AMPs allows for diffused payment graphs and reduces strain on individual paths, potentially leading to non-negligible impacts on channel longevity. It also has potential fee savings for larger payments, side-stepping the current limit on max payment sizes. With sufficient path diversity, AMPs may improve the privacy of LN as intermediaries are unaware of how much of the total payment they are forwarding.To include the three tuple within the per-hop payload for the final destination, the first byte of the un-used padding bytes in the payload is repurposed to signal version 0x01 of the AMP protocol. The realm byte controls the interpretation of the rest of the 65-byte packet and can be used to redefine the entire 64 bytes of the final hop data as desired.The solution leverages EOBs to deliver additive shares of a base preimage from which the payment preimages of partial payments can be derived. The sender divides the total payment value into n partial payments and constructs a base preimage, from which n partial preimages will be derived. The sender then computes the n partial preimages and initiates each payment with the tuple (ID, n, s_i) included in the EOB to be opened by the receiver.The receiver iteratively reconstructs BP upon the arrival of each partial payment and does some bookkeeping to figure out when to settle the partial payments. During this reconstruction process, the receiver does not need to be aware of the order in which the payments were sent, and in fact nothing about the incoming partial payments reveals this information to the receiver, though this can be learned after reconstructing BP. Each EOB is decoded to retrieve (ID, n, s_i), where i is the unique but unknown index of the incoming partial payment.The receiver has access to persistent key-value store DB that maps ID to (n, c*, BP*), where c* represents the number of partial payments received, BP* is the sum of the received additive shares, and the superscript * denotes that the value is being updated iteratively. In the basic protocol, the receiver caches the first n it sees, and verifies that all incoming partial payments have the same n. The receiver should reject all partial payments if any EOB deviates.Next, we update our persistent store with DB[ID] = (n, c* + 1, BP* ^ s_i), advancing the reconstruction by one step. If c* + 1, the receiver can then combine the additive shares to obtain BP.The sender and receiver negotiate the end-to-end protocol, which requires no fundamental changes to the protocol as it is now. Potential fee savings for larger payments could be achieved with modifications to the fee schedule. The existence of per-hop fees means that splitting the payment over multiple flows may be more expensive compared to using a single flow. Using smaller payments increases the set of possible paths a partial payment could have taken, which reduces the effectiveness of static analysis techniques involving channel capacities and the plaintext values being forwarded. If AMP is supported only at final payees, it is possible to completely redefine the 64 bytes in the final hop data for the new AMP `realm`, and not consume the next hop, which would reduce route length by one.</summary>
    <published>2018-02-06T05:26:30+00:00</published>
  </entry>
</feed>
